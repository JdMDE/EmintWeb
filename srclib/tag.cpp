/*
    See notes in tag.h
    Copyright (C) 2013  Juan Domingo Esteve <Juan.Domingo@uv.es>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "tag.h"

extern bool DEBLIB;

internal::r_Tag::r_Tag(string label)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag constructor type/label with |" << label << "|\n";
 
 taglabel=label;
 tagattributes="";
 tagsiblings.clear();
 numopm=0;
 istext=false;
}

internal::r_Tag::r_Tag(string label, string attributes)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag constructor type/label/attributes with |" << label << "| |" << attributes << "|\n";
 
 taglabel=label;
 tagattributes=attributes.substr(0,attributes.find_last_not_of(" ")+1);
 tagsiblings.clear();
 numopm=0;
 istext=false;
}

internal::r_Tag::r_Tag(r_Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag copy constructor.\n";
 
 taglabel=other.taglabel;
 tagattributes=other.tagattributes;
 tagsiblings.clear();
 numopm=0;
 istext=other.istext;
 for (unsigned i=0;i<other.tagsiblings.size();i++)
  tagsiblings.push_back(other.tagsiblings[i]);
}

internal::r_Tag::~r_Tag()
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag destructor.\n";
 
 cleanmem();
}

void internal::r_Tag::cleanmem()
{
 for (unsigned i=0; i<tagsiblings.size(); i++)
  if ((tagsiblings[i] != NULL) && (tagsiblings[i]->numopm==0))
   tagsiblings[i]->cleanmem();
  
 if (numopm == 0)
  free(this);
}

internal::r_Tag& internal::r_Tag::operator=(internal::r_Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag = operator.\n";
 
 if ( &other == this )
	return *this;
 
 taglabel=other.taglabel;
 tagattributes=other.tagattributes;
 tagsiblings.clear();
 numopm=0;
 istext=other.istext;
 for (unsigned i=0;i<other.tagsiblings.size();i++)
  tagsiblings.push_back(other.tagsiblings[i]);
 
 return *this;
}

bool internal::r_Tag::operator==(internal::r_Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag == operator.\n";

 if (tagsiblings.size()!=other.tagsiblings.size())
  return false;
 
 if ( (taglabel!=other.taglabel) ||
      (tagattributes!=other.tagattributes) ||
	   (istext!=other.istext)
    )
  return false;
 
 bool ret=true;
 unsigned i=0;
 while (i<tagsiblings.size() && ret && tagsiblings[i]==other.tagsiblings[i])
  i++;
 
 return ret;
}

void internal::r_Tag::add(internal::r_Tag *other)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag add.\n";
 
 tagsiblings.push_back(other);
 other->incopm();
}

void internal::r_Tag::setcontent(string content)
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag setcontent.\n";

 internal::r_Tag *text = new internal::r_Tag( content, "" );
 text->settext(true);
 tagsiblings.push_back(text);
 text->incopm();
}

void internal::r_Tag::incopm()
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag incopm for tag " << taglabel << " from " << numopm;
 
 numopm++;
 for (unsigned i=0; i<tagsiblings.size(); i++)
  tagsiblings[i]->incopm();
 
 if (DEBLIB)
  cout << " to " << numopm << endl;
}

void internal::r_Tag::decopm()
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag decopm from " << numopm;
 
 if (numopm>0)
  numopm--;
 for (unsigned i=0; i<tagsiblings.size(); i++)
  tagsiblings[i]->decopm();
 
 if (DEBLIB)
  cout << " to " << numopm << endl;
}

string internal::r_Tag::generate( string basicident, string ident )
{
 if (DEBLIB)
  cout << "DEBLIB: r_Tag generate.\n";
 
 string ret="";
 size_t s=tagsiblings.size(); 

 // The html is special, the tag itself is generated by the htmldocument class
 // and here we only have to generate the contents.
 if ( taglabel == "html" )
 {
  for(unsigned i=0; i<s; i++)
   ret += tagsiblings[i]->generate(basicident,ident);
  return ret;
 }
 
 // The result of generating a text tag is itself.
 if ( istext )
  return ident+taglabel+"\n";
 
 // In case of normal tags, first, we open the tag...
 ret = ident+"<"+taglabel;
 
 // ...add the attributes, if there are such thing,
 if ( tagattributes != "" )
  ret += " "+tagattributes;
 
 // and: if we have no children, close the tag and return.
 if ( s == 0 )
  return ( ret+"/>\n" );

 // if we have exactly one children (normally, a text tag) build all in a single line
 if (( s == 1 ) && ( tagsiblings[0]->istext ))
  return ( ret+">"+tagsiblings[0]->taglabel+"</"+taglabel+">\n" );
 
 // if we have several children, close the initial tag...
 ret += ">\n";
 
 // ...generate content for each child, adding one more level of identation...
 string moreident=basicident+ident;
 for (unsigned i=0; i<s; i++)
  ret += tagsiblings[i]->generate(basicident,moreident);
 
 // ...and generate the closing tag.
 ret += ident+"</"+taglabel+">\n";
 
 return ret;
}

Tag::Tag(string tag)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag constructor tag with |" << tag << "|\n";;

 TaglabelDefs *syntax=TaglabelDefs::instance();

 if (DEBLIB)
  cout << "DEBLIB: syntax=" << syntax << endl;

 int t=syntax->toNum(tag);
 if ( t == HTML_NO_TAG )
 {
  cerr << "Error: " << tag << " is not a valid HTML tag.\n";
  exit(1);
 }
 p=new internal::r_Tag(tag);
 p->incopm();
}

Tag::Tag(string tag, string attributes)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag constructor tag/attributes with |" << tag << "| |" << attributes << "|\n";
 
 TaglabelDefs *syntax=TaglabelDefs::instance();

 if (DEBLIB)
  cout << "DEBLIB: syntax=" << syntax << endl;

 int t=syntax->toNum(tag);
 if ( t == HTML_NO_TAG )
 {
  cerr << "Error: " << tag << " is not a valid HTML tag.\n";
  exit(1);
 }
 p=new internal::r_Tag(tag,attributes);
 p->incopm();
}

Tag::Tag(Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag copy constructor.\n";
 
 p=other.p;
 p->incopm();
}

Tag::~Tag()
{
 if (DEBLIB)
  cout << "DEBLIB: Tag destructor.\n";
 
 if (p!=NULL)
 {
  p->decopm();
  if (p->getopm() == 0)
   p->cleanmem();
 }
}

Tag &Tag::operator=(Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag = operator.\n";
 
 if ( &other == this )
  return *this;
 
 p=other.p;
 p->incopm();
 
 return *this;
}

bool Tag::operator==(Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag == operator.\n";
 
 return p==other.p;
}

void Tag::add(Tag &other)
{
 if (DEBLIB)
  cout << "DEBLIB: Tag add.\n";
 
 p->add(other.GetP());
}
